var documenterSearchIndex = {"docs":
[{"location":"guide/#Guide","page":"Guide","title":"Guide","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Documentation may not be accurate as this is a beta stage package undergoing changes. Raise Github issue if you have questions :)","category":"page"},{"location":"guide/#Installation","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"We're a registered Julia package, but it's recommended to install the latest revision directly from Github.","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"using Pkg; Pkg.add(url=\"https://github.com/aced-differentiate/EquivariantOperators.jl.git\")","category":"page"},{"location":"guide/#Scalar-and-vector-fields","page":"Guide","title":"Scalar & vector fields","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Scalar & vector fields are represented as 2d/3d arrays of canonically scalars or vectors (StaticVectors from StaticArrays.jl for performance). This vector field representation is consistent with multi-channel images from Julia Images which differs from representations using separate arrays for field components. Most Images functions are readily applicable. Array values can alternatively be any custom type that Supports addition & multiplication, such as complex numbers and custom structs encoding spherical harmonics.","category":"page"},{"location":"guide/#Customizable-grid,-interpolation,-particle-mesh-placement","page":"Guide","title":"Customizable grid, interpolation, particle mesh placement","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Grid\r\nplace!","category":"page"},{"location":"guide/#Grid","page":"Guide","title":"Grid","text":"Grid(resolutions, origin=ones(length(resolutions)), sz=nothing)\nGrid(resolutions, rmax)\nGrid(cell, origin=ones(size(cell, 1)), sz=nothing)\nGrid(cell, rmax)\n\nConstructs Grid for interpolation, coordinate retrieval, and particle mesh placement. Grids can be in any dimension and be boundless or bounded. At minimum, a grid stores its discretization cell and origin in pixels. \n\nFor an orthogonal grid, supply a list of resolutions in each dimension. For non-orthogonal grid, supply the cell vectors as a column-wise matrix. Origin by default is at index (1, ...).\n\nBounded grids compute and store additional info eg position vectors and their norms of all grid points. To construct bounded grid, supply the overall integer pixel size sz. For bounded cubic grid, use convenience constructor with rmax \n\nParams\n\nresolutions: list of resolutions in each dimension for orthogonal grids\norigin: indices of the origin, may be decimal valued\nsz: integer size (pixel dimensions) of bounded grid\nrmax: halflength (in length units, not pixels) of bounded cubic grid\ncell: column-wise matrix of discretization cell vectors\n\nfields\n\ncell\norigin\nadditional fields of bounded grids\np: Array of position vectors\nr: Array of radial distances (lengths of position vectors)\nx, y, z: Array of that coordinate (field aliases calling p)\n\nExamples\n\n2d interpolation\n\ndx = dy = 0.1\ng = Grid((dx, dy))\na = [x^2 + y^2 for x in 0:dx:0.5, y in 0:dy:0.5]\na[g, 0.25, 0.25]\n# 0.13\n\n# alternatively the example array can be made using a bounded grid and its coordinate fields\nR = 0.5\ng = Grid((dx, dy), R)\na = g.x.^2 + g.y.^2 # or g.r.^2\n\ngrid construction details\n\nGrid((0.1,)) # 1d grid spaced 0.1 apart with origin at (1,)\nGrid((0.1, 0.2), (2, 5)) # 2d grid spaced 0.1 along x and 0.2 along y, with origin at (2 ,5)\nGrid((0.1, 0.1), 20.0) # bounded 2d grid spaced 0.1 apart, halflength 20.0, with origin at (201, 201), pixel size (401, 401)\nGrid(0.1 * [1 1 0; 1 0 1; 1 1 1]', ones(3), (10, 12, 15)) # bounded 3d grid with cell vectors [.1, .1, 0], [.1, 0, .1], [.1, .1, .1] (note matrix transpose). origin (1, 1, 1), pixel size (10, 12, 15). can construct lattice this way\n\n\n\n\n\n","category":"type"},{"location":"guide/#place!","page":"Guide","title":"place!","text":"place!(field, grid, rvec, val)\n\nPlace a discrete impulse value via particle mesh method, specifically using area weighting according to the CIC (cloud-in-cell) rule. The impulse is thus spread onto the nearest grid points with proximity weighting and discretization scaling.\n\nparticle mesh placement and interpolation\n\ndx = dy = dz = 0.1\ng = Grid((dx, dy, dz))\na = zeros(5, 5, 5)\nv = 1.0\nplace!(a, g, (0.2, 0.2, 0.2), v)\n\na[g, 0.2, 0.2, 0.2]\n# 1000\nv / g.dv\n# 1000\n\n\n\n\n\n","category":"function"},{"location":"guide/#Finite-difference-equivariant-operators","page":"Guide","title":"Finite difference equivariant operators","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Del\r\nLap\r\nGauss\r\nOp","category":"page"},{"location":"guide/#Del","page":"Guide","title":"Del","text":"Del(resolutions; pad = :same, border = :smooth)\nDel(cell; pad = :same, border = :smooth)\n\nconstructs gradient operator (also divergence, curl) using central difference stencil. By default, boundaries are smooth (C1 or C2 continuous) and output is of same length as input.\n\nExample\n\n1d derivative\n\ndx = 0.1\nx = 0:dx:.5\ny = x .^ 2\nd = Del((dx,))\nd(y)\n\n#=\n6-element Vector{Float64}:\n 0.0\n 0.2\n 0.4\n 0.6\n 0.8\n 1.0\n=#\n\n2d gradient\n\ndy = dx = 0.1\na = [x^2 + y^2 for x in 0:dx:0.5, y in 0:dy:0.5]\n▽ = Del((dx, dy))\ngrad_a = ▽(a)\n\n#=\n6×6 Matrix{SVector{2, Float64}}:\n[0.2, 0.2]  [0.2, 0.2]  [0.2, 0.4]  [0.2, 0.6]  [0.2, 0.8]  [0.2, 0.8]\n [0.2, 0.2]  [0.2, 0.2]  [0.2, 0.4]  [0.2, 0.6]  [0.2, 0.8]  [0.2, 0.8]\n [0.4, 0.2]  [0.4, 0.2]  [0.4, 0.4]  [0.4, 0.6]  [0.4, 0.8]  [0.4, 0.8]\n [0.6, 0.2]  [0.6, 0.2]  [0.6, 0.4]  [0.6, 0.6]  [0.6, 0.8]  [0.6, 0.8]\n [0.8, 0.2]  [0.8, 0.2]  [0.8, 0.4]  [0.8, 0.6]  [0.8, 0.8]  [0.8, 0.8]\n [0.8, 0.2]  [0.8, 0.2]  [0.8, 0.4]  [0.8, 0.6]  [0.8, 0.8]  [0.8, 0.8]\n=#\n\n2d divergence\n\ndy = dx = 0.1\na = [[2x,3y] for x in 0:dx:0.5, y in 0:dy:0.5]\n▽ = Del((dx, dy))\n▽ ⋅ (a)\n#=\n6×6 Matrix{Float64}:\n 5.0  5.0  5.0  5.0  5.0  5.0\n 5.0  5.0  5.0  5.0  5.0  5.0\n 5.0  5.0  5.0  5.0  5.0  5.0\n 5.0  5.0  5.0  5.0  5.0  5.0\n 5.0  5.0  5.0  5.0  5.0  5.0\n 5.0  5.0  5.0  5.0  5.0  5.0\n=#\n\n\n\n\n\n","category":"function"},{"location":"guide/#Lap","page":"Guide","title":"Lap","text":"Lap(cell; pad = :same, border = :smooth)\n\nconstructs Laplacian operator\n\nExamples\n\n# 2d Example\ndy = dx = 0.1\na = [x^2 + y^2 for x in 0:dx:0.5, y in 0:dy:0.5]\n▽2 = Lap((dx, dy))\n▽2(a)\n\n#=\n6×6 Matrix{Float64}:\n 4.0  4.0  4.0  4.0  4.0  4.0\n 4.0  4.0  4.0  4.0  4.0  4.0\n 4.0  4.0  4.0  4.0  4.0  4.0\n 4.0  4.0  4.0  4.0  4.0  4.0\n 4.0  4.0  4.0  4.0  4.0  4.0\n 4.0  4.0  4.0  4.0  4.0  4.0\n=#\n\n\n\n\n\n","category":"function"},{"location":"guide/#Gauss","page":"Guide","title":"Gauss","text":"Gauss(resolutions, σ, rmax; kw...)\nGauss(cell, σ, rmax; kw...)\n\nconstructs Gaussian diffusion operator with volume Normalized to 1 wrt grid support\n\n\n\n\n\n","category":"function"},{"location":"guide/#Op","page":"Guide","title":"Op","text":"Op(radfunc, rmax, resolutions; l = 0, rmin = 0., pad = :same)\nOp(radfunc, rmax, cell; kw...)\nOp(radfunc, grid; kw...)\n\nOp constructs equivariant finite difference operators & custom Green's functions by specifying the radial function of the impulse response. Prebuilt operators like differential operators (▽) & common Green's functions can be constructed instead using Del, Lap.\n\nArgs\n\nl: rotation order, 0 for scalar field, 1 for vector field\n\nExample\n\ndx = dy = 0.1\nresolutions = (dx, dy)\nrmin = 1e-9\nrmax = 0.2\nϕ = Op(r -> 1 / r, rmax, resolutions; rmin) # 1/r potential\nF = Op(r -> 1 / r^2, rmax, resolutions; rmin, l=1) # 1/r^2 field\n\ng = Grid(resolutions,)\na = zeros(5, 5)\na[3, 3] = 1.0 / g.dv # puts discrete value integrating to 1.0 onto array\n\nϕ(a)\n#=\n5×5 Matrix{Float64}:\n 0.0   0.0       5.0   0.0      0.0\n 0.0   7.07107  10.0   7.07107  0.0\n 5.0  10.0       0.0  10.0      5.0\n 0.0   7.07107  10.0   7.07107  0.0\n 0.0   0.0       5.0   0.0      0.0\n=#\n\nF(a)\n#=\n5×5 Matrix{SVector{2, Float64}}:\n [0.0, 0.0]    [0.0, 0.0]            [-25.0, 0.0]   [0.0, 0.0]           [0.0, 0.0]\n [0.0, 0.0]    [-35.3553, -35.3553]  [-100.0, 0.0]  [-35.3553, 35.3553]  [0.0, 0.0]\n [0.0, -25.0]  [0.0, -100.0]         [0.0, 0.0]     [0.0, 100.0]         [0.0, 25.0]\n [0.0, 0.0]    [35.3553, -35.3553]   [100.0, 0.0]   [35.3553, 35.3553]   [0.0, 0.0]\n [0.0, 0.0]    [0.0, 0.0]            [25.0, 0.0]    [0.0, 0.0]           [0.0, 0.0]\n=#\n\n\n\n\n\nfunction (m::Op)(x::AbstractArray, )\n\n\n\n\n\n","category":"type"},{"location":"guide/#Convolutions","page":"Guide","title":"Convolutions","text":"","category":"section"},{"location":"guide/","page":"Guide","title":"Guide","text":"Operators apply to most use cases but you may also use convolution functions directly. We offer feature rich convolution and cross correlation functions with options for padding, stride, boundary conditions, and custom products (tensor field convolutions). We use DSP.conv as our backend for scalar field convolutions and our own implementations for convolutions involving vector fields or custom products. FFT implementation is automatically invoked when appropriate. ","category":"page"},{"location":"guide/","page":"Guide","title":"Guide","text":"cvconv\r\ndspconv","category":"page"},{"location":"guide/#cvconv","page":"Guide","title":"cvconv","text":"cvconv(x, f; product = *, stride = 1, pad = 0, alg = nothing)\n\n\"convolution\" in computer vision for any dimension, same as Cross correlation. Automatically uses FFT for big kernels. For convolution in signal processing , use dspconv instead.\n\nArgs\n\nx input array\nf filter array\n\nKeywords\n\nproduct product in convolution, eg *, dot\npad amount of padding or padding option\nany integer number of pixels on each boundary\n:same: adds enough padding so ouoverlapdotut is same size as input\n:outer: ouoverlapdotut size is size(x) .+ size(f) .- 1\nborder type of padding\n0 value pixels\n:replicate repeats edge values\nperiodic or :circular: periodic BC\n:smooth continuous derivatives at boundaries useful for differential operators\n:reflect reflects interior across boundaries which are not repeated\n:symmetric same as :reflect but with boundaries repeated\nalg specifies convolution algorithm\nnothing Automatically chooses fastest algorithm\n:direct convolution, scales as O(n^2)\n:fft Fourier convolution, scales as O(n log(n))\n\nConvolutions in other Julia packages, fewer features but perhaps more optimized for speed in their specific use cases\n\nImageFiltering.imfilter. Its docs has excellent mathematical explaination of convolutions and correlation as well as padding/border options\nDSP.conv DSP.xcor\nFlux.conv\n\n\n\n\n\n","category":"function"},{"location":"guide/#dspconv","page":"Guide","title":"dspconv","text":"dspconv(a, f; product = *, pad = :outer, border=0)\n\nConvolution in signal processing. For \"convolution\" in computer vision, use cvconv instead. Automatically uses FFT for big kernels. By default output size is size(x) .+ size(f) .- 1. See cvconv for its keyword options which also apply here\n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Hosted on Colab notebooks","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"#Synopsis","page":"Home","title":"Synopsis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EquivariantOperators.jl implements in Julia fully differentiable finite difference and Green's function operators on scalar or vector fields in any dimension. Utilities for grid interpolation, particle mesh methods, boundary conditions and convolutions are also included. It can run forwards for FDTD simulation or image processing, or back propagated for machine learning or inverse problems. Emphasis is on symmetry preserving rotation equivariant operators, including differential operators, common Green's functions & parametrized neural operators. Supports scalar and vector field convolutions with customizable products eg  dot. Automatically performs convolutions using FFT when it's faster doing so. Supports possibly nonuniform, nonorthogonal or periodic grids.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Array operators in any dimension including derivative, gradient, divergence, Laplacian, curl, and customizable Green's functions\nInterpolation and particle mesh methods on possibly non-orthogonal grids\nBoundary conditions including periodic, smooth, zero, mirror\nFeature rich convolutions on scalar arrays and vector fields with automatic FFT computation when appropriate\nFully differentiable compatible with Flux Zygote","category":"page"},{"location":"#Github","page":"Home","title":"Github","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Star us at Github :) Raise Github issue if you have questions :)","category":"page"},{"location":"#Theory","page":"Home","title":"Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Equivariant linear operators are our building blocks. Equivariance means a rotation of the input results in the same rotation of the output thus preserving symmetry. Applying a linear operator convolves the input with the operator's kernel. If the operator is also equivariant, then its kernel must be radially symmetric. Differential operators and Green's functions are in fact equivariant linear operators. We provide built in constructors for these common operators. By parameterizing the radial function, we can also construct custom neural equivariant operators for machine learning.","category":"page"},{"location":"#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Preprint outdated, releasing new version soon","category":"page"},{"location":"","page":"Home","title":"Home","text":"Preprint: Paul Shen, Michael Herbst, Venkat Viswanathan. Rotation Equivariant  Operators for Machine Learning on Scalar Fields and Vector Fields. Arxiv. 2022.","category":"page"},{"location":"#Contributors","page":"Home","title":"Contributors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lead developer: Paul Shen (pxshen@alumni.stanford.edu)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Collaborators: Michael Herbst (herbst@acom.rwth-aachen.de)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"PI: Venkat Viswanathan (venkatv@andrew.cmu.edu)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In collaboration with Julia Computing","category":"page"},{"location":"autodiff/#Automatic-differentiation","page":"Automatic differentiation","title":"Automatic differentiation","text":"","category":"section"},{"location":"autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"Most of the package is compatible with autodiff in Flux and Zygote. Exceptions:","category":"page"},{"location":"autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"may or may not work with FFT convolutions. set alg = :direct if encountering autodiff error\nsome special border options ","category":"page"},{"location":"autodiff/","page":"Automatic differentiation","title":"Automatic differentiation","text":"An alternative autodiff package is Enzyme.jl which works at the LLVM level and can handle limitations in Zygote eg array mutation. It's probably the future of autodiff in Julia/C++ but isn't yet mature.","category":"page"}]
}
